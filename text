val ev = eventsDF

// Player goals requires event type indicating goal (depending on dataset specifics)
val playerGoals = ev
  .filter(col("event_type").isin("Goal", "Own Goal", "Penalty Goal")) // adjust event types as per your data
  .groupBy("player_id", "match_id")
  .agg(count("*").alias("goals_scored"))

// Join player goals with player info if needed
val playerStats = tPlayer
  .join(playerGoals, tPlayer("player_api_id") === playerGoals("player_id"), "left")
  .na.fill(0, Seq("goals_scored"))

// Example write or further processing
writeTable(playerStats.select("player_api_id", "player_name", "goals_scored"), s"$targetSchema.fact_player_goals")

// === VALIDATIONS ===
println("ðŸ” Running post-load validations...")

val cntFact = spark.read.jdbc(jdbcUrl, s""""$targetSchema"."fact_match"""", jdbcProps).count()
val cntTeamSeason = spark.read.jdbc(jdbcUrl, s""""$targetSchema"."fact_team_season"""", jdbcProps).count()
println(s"Post-load counts: fact_match=$cntFact, fact_team_season=$cntTeamSeason")

val factMatchDF = spark.read.jdbc(jdbcUrl, s""""$targetSchema"."fact_match"""", jdbcProps)
val dimLeagueDF = spark.read.jdbc(jdbcUrl, s""""$targetSchema"."dim_league"""", jdbcProps)

val missingLeagueFK = factMatchDF.join(dimLeagueDF, factMatchDF("league_id") === dimLeagueDF("league_id"), "left_anti")
if (missingLeagueFK.count() > 0) {
  println(s"âš  Warning: ${missingLeagueFK.count()} fact_match rows have league_id that don't exist in dim_league.")
} else {
  println("âœ… All league_ids in fact_match have matching entries in dim_league.")
}

val dupMatches = factMatchDF.groupBy("match_id").count().filter("count > 1")
if (dupMatches.count() > 0) {
  println(s"âš  Duplicate match_id found: ${dupMatches.count()} rows")
} else {
  println("âœ… No duplicate match_ids found.")
}

createIndexes()
println("âœ… Full ETL finished successfully.")
