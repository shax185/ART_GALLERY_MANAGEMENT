package etl

import org.apache.spark.sql.{DataFrame, SaveMode, SparkSession}
import org.apache.spark.sql.functions._
import org.apache.spark.sql.types._
import org.apache.spark.sql.expressions.Window
import java.sql.DriverManager
import java.util.Properties

object FullLeagueETL1 {

  // ---------- CONFIG ----------
  val jdbcUrl = "jdbc:postgresql://localhost:5432/FootballETL"
  val dbUser  = "postgres"
  val dbPass  = "root"
  val dbDriver = "org.postgresql.Driver"
  val targetSchema = "football_dw1"
  val keepLastNForForm = 5 // rolling form window
  val minRivalryMeetings = 10
  // ----------------------------

  private def ensureSchemaExists(): Unit = {
    Class.forName(dbDriver)
    val conn = DriverManager.getConnection(jdbcUrl, dbUser, dbPass)
    try {
      val stmt = conn.createStatement()
      stmt.execute(s"CREATE SCHEMA IF NOT EXISTS $targetSchema;")
      stmt.close()
      println(s"âœ… Ensured schema: $targetSchema")
    } finally conn.close()
  }

  private def jdbcProps: Properties = {
    val p = new Properties()
    p.setProperty("user", dbUser)
    p.setProperty("password", dbPass)
    p.setProperty("driver", dbDriver)
    p
  }

  private def readTable(spark: SparkSession, tableName: String): DataFrame = {
    spark.read
      .jdbc(jdbcUrl, s""""public"."$tableName"""", jdbcProps)
      .persist()
  }

  private def writeTable(df: DataFrame, fullTableName: String): Unit = {
    df.write
      .mode(SaveMode.Overwrite)
      .jdbc(jdbcUrl, fullTableName, jdbcProps)
    println(s"âœ… Wrote ${df.count()} rows to $fullTableName")
  }

  private def createIndexes(): Unit = {
    Class.forName(dbDriver)
    val conn = DriverManager.getConnection(jdbcUrl, dbUser, dbPass)
    try {
      val stmt = conn.createStatement()
      val idxs = Seq(
        s"CREATE INDEX IF NOT EXISTS idx_fact_match_league_season ON $targetSchema.fact_match (league_id, season);",
        s"CREATE INDEX IF NOT EXISTS idx_fact_match_home_team ON $targetSchema.fact_match (home_team_id);",
        s"CREATE INDEX IF NOT EXISTS idx_fact_match_away_team ON $targetSchema.fact_match (away_team_id);",
        s"CREATE INDEX IF NOT EXISTS idx_fact_team_season_team ON $targetSchema.fact_team_season (team_id, season);",
        s"CREATE INDEX IF NOT EXISTS idx_fact_league_season_league ON $targetSchema.fact_league_season (league_id, season);"
      )
      idxs.foreach(sql => stmt.execute(sql))
      stmt.close()
      println("âœ… Created indexes on DW tables")
    } finally conn.close()
  }

  def run(spark: SparkSession): Unit = {
    import spark.implicits._
    spark.sparkContext.setLogLevel("WARN")

    ensureSchemaExists()

    // === EXTRACT ===
    println("ðŸ” Extracting raw tables...")
    val tCountry = readTable(spark, "Country")
    val tLeague = readTable(spark, "League")
    val tTeam = readTable(spark, "Team")
    val tMatch = readTable(spark, "Match")
    val tPlayer = try { readTable(spark, "Player") } catch { case _: Throwable => spark.emptyDataFrame }
    val tPlayerAttr = try { readTable(spark, "Player_Attributes") } catch { case _: Throwable => spark.emptyDataFrame }
    val tTeamAttr = try { readTable(spark, "Team_Attributes") } catch { case _: Throwable => spark.emptyDataFrame }

    println(s"Extracted rows -> Country: ${tCountry.count()}, League: ${tLeague.count()}, Team: ${tTeam.count()}, Match: ${tMatch.count()}")

    // === DIMENSION FILTERING ===
    val relevantLeagues = Set(
      "England Premier League",
      "France Ligue 1",
      "Germany 1. Bundesliga",
      "Italy Serie A",
      "Spain LIGA BBVA"
    )

    val dimLeagueFiltered = tLeague
      .select(
        col("id").cast(IntegerType).alias("league_id"),
        col("country_id").cast(IntegerType),
        trim(col("name")).alias("league_name")
      )
      .filter(col("name").isin(relevantLeagues.toSeq:_*))
      .na.drop(Seq("league_id"))
      .dropDuplicates("league_id")

    val relevantCountryIds = dimLeagueFiltered.select("country_id").distinct()

    val dimCountryFiltered = tCountry
      .select(
        col("id").cast(IntegerType).alias("country_id"),
        trim(col("name")).alias("country_name")
      )
      .join(relevantCountryIds, Seq("country_id"), "inner")
      .na.drop(Seq("country_id"))
      .dropDuplicates("country_id")

    // === FACT MATCH CLEAN + ENRICH ===
    val matchCols = Seq(
      "id", "country_id", "league_id", "season", "stage", "date",
      "match_api_id", "home_team_api_id", "away_team_api_id",
      "home_team_goal", "away_team_goal"
    ).filter(c => tMatch.columns.contains(c))

    val factMatchRaw = tMatch.select(matchCols.map(col): _*)

    val factMatchTyped = factMatchRaw
      .withColumn("match_id", col("id").cast(IntegerType))
      .withColumn("league_id", col("league_id").cast(IntegerType))
      .withColumn("country_id", col("country_id").cast(IntegerType))
      .withColumn("season", col("season").cast(StringType))
      .withColumn("date", to_timestamp(col("date")))
      .withColumn("home_team_id", col("home_team_api_id").cast(IntegerType))
      .withColumn("away_team_id", col("away_team_api_id").cast(IntegerType))
      .withColumn("home_team_goal", col("home_team_goal").cast(IntegerType))
      .withColumn("away_team_goal", col("away_team_goal").cast(IntegerType))
      .select("match_id", "league_id", "country_id", "season", "date", "home_team_id", "away_team_id", "home_team_goal", "away_team_goal")

    // Filter matches to relevant leagues & countries
    val factMatchFiltered = factMatchTyped
      .join(dimLeagueFiltered.select("league_id"), Seq("league_id"), "inner")
      .join(dimCountryFiltered.select("country_id"), Seq("country_id"), "inner")

    val factMatchClean = factMatchFiltered
      .filter(col("home_team_goal").isNotNull && col("away_team_goal").isNotNull && col("date").isNotNull)
      .filter(col("home_team_goal") >= 0 && col("away_team_goal") >= 0)
      .dropDuplicates("match_id")

    val factMatchEnriched = factMatchClean
      .withColumn("result",
        when(col("home_team_goal") > col("away_team_goal"), lit("Home Win"))
          .when(col("home_team_goal") < col("away_team_goal"), lit("Away Win"))
          .otherwise(lit("Draw"))
      )
      .withColumn("goal_difference", col("home_team_goal") - col("away_team_goal"))
      .withColumn("home_points",
        when(col("home_team_goal") > col("away_team_goal"), lit(3))
          .when(col("home_team_goal") === col("away_team_goal"), lit(1))
          .otherwise(lit(0))
      )
      .withColumn("away_points",
        when(col("away_team_goal") > col("home_team_goal"), lit(3))
          .when(col("away_team_goal") === col("home_team_goal"), lit(1))
          .otherwise(lit(0))
      )
      .withColumn("season_start_year", regexp_extract(col("season"), """(\d{4})""", 1).cast(IntegerType))
      .withColumn("match_week", weekofyear(col("date")))
      .withColumn("match_date", to_date(col("date")))

    // === RELEVANT TEAMS (for filtering dim_team and players) ===
    val relevantTeamIds = factMatchEnriched
      .select("home_team_id").withColumnRenamed("home_team_id", "team_id")
      .union(factMatchEnriched.select(col("away_team_id").alias("team_id")))
      .distinct()

    val dimTeam = tTeam
      .withColumn("team_id", when(col("team_api_id").isNotNull, col("team_api_id")).otherwise(col("id")))
      .select(
        col("team_id").cast(IntegerType),
        trim(col("team_long_name")).alias("team_name"),
        trim(col("team_short_name")).alias("team_short_name")
      )
      .na.drop(Seq("team_id"))
      .dropDuplicates("team_id")
      .join(relevantTeamIds, Seq("team_id"), "inner")

    // === WRITE DIMENSIONS ===
    writeTable(dimCountryFiltered, s"$targetSchema.dim_country")
    writeTable(dimLeagueFiltered, s"$targetSchema.dim_league")
    writeTable(dimTeam, s"$targetSchema.dim_team")
    writeTable(factMatchEnriched, s"$targetSchema.fact_match")

    // === TEAM-SEASON AGGREGATES ===
    val homePerspective = factMatchEnriched.select(
      col("match_id"), col("season"), col("league_id"), col("match_date"),
      col("home_team_id").alias("team_id"), col("away_team_id").alias("opponent_team_id"),
      col("home_team_goal").alias("goals_for"), col("away_team_goal").alias("goals_against"),
      col("home_points").alias("points")
    ).withColumn("is_home", lit(true))

    val awayPerspective = factMatchEnriched.select(
      col("match_id"), col("season"), col("league_id"), col("match_date"),
      col("away_team_id").alias("team_id"), col("home_team_id").alias("opponent_team_id"),
      col("away_team_goal").alias("goals_for"), col("home_team_goal").alias("goals_against"),
      col("away_points").alias("points")
    ).withColumn("is_home", lit(false))

    val teamMatchPerspective = homePerspective.unionByName(awayPerspective)
      .filter(col("team_id").isNotNull)
      .persist()

    val factTeamSeason = teamMatchPerspective.groupBy("season", "league_id", "team_id")
      .agg(
        countDistinct("match_id").alias("matches_played"),
        sum(when(col("points") === 3, 1).otherwise(0)).alias("wins"),
        sum(when(col("points") === 1, 1).otherwise(0)).alias("draws"),
        sum(when(col("points") === 0, 1).otherwise(0)).alias("losses"),
        sum("goals_for").alias("goals_for"),
        sum("goals_against").alias("goals_against"),
        (sum("goals_for") - sum("goals_against")).alias("goal_difference"),
        sum("points").alias("points"),
        round(sum("points") / countDistinct("match_id"), 3).alias("win_rate")
      )
      .persist()

    writeTable(factTeamSeason, s"$targetSchema.fact_team_season")

    // === LEAGUE-SEASON AGGREGATES ===
    val factLeagueSeason = factTeamSeason.groupBy("season", "league_id")
      .agg(
        sum("matches_played").alias("total_matches"),
        round(avg("goals_for"), 2).alias("avg_goals_per_team"),
        round(avg("points"), 2).alias("avg_points_per_team"),
        max("points").alias("points_max")
      )

    writeTable(factLeagueSeason, s"$targetSchema.fact_league_season")

    // === ROLLING TEAM FORM ===
    val w = Window.partitionBy("team_id").orderBy(col("match_date").cast("timestamp")).rowsBetween(-keepLastNForForm, -1)
    val teamForm = teamMatchPerspective
      .withColumn("rolling_goals_for_lastN", sum("goals_for").over(w))
      .withColumn("rolling_goals_against_lastN", sum("goals_against").over(w))
      .withColumn("rolling_points_lastN", sum("points").over(w))
      .withColumn("form_matches", count("match_id").over(w))
      .select("team_id", "league_id", "season", "match_date", "form_matches", "rolling_points_lastN", "rolling_goals_for_lastN", "rolling_goals_against_lastN")
      .na.fill(0)

    writeTable(teamForm, s"$targetSchema.fact_team_form")

    // === TEAM PROGRESS (cumulative points over season timeline) ===
    val progressWindow = Window.partitionBy("season", "team_id").orderBy("match_date").rowsBetween(Window.unboundedPreceding, Window.currentRow)
    val teamProgress = teamMatchPerspective
      .withColumn("cumulative_points", sum("points").over(progressWindow))
      .select("season", "league_id", "team_id", "match_date", "cumulative_points")
      .persist()

    writeTable(teamProgress, s"$targetSchema.fact_team_progress")

    // === LEAGUE STANDINGS (ranked) ===
    val standingsWindow = Window.partitionBy("season", "league_id").orderBy(col("points").desc, col("goal_difference").desc)
    val leagueStandings = factTeamSeason
      .withColumn("rank", row_number().over(standingsWindow))
      .select("season", "league_id", "team_id", "matches_played", "wins", "draws", "losses", "goals_for", "goals_against", "goal_difference", "points", "win_rate", "rank")
      .persist()

    writeTable(leagueStandings, s"$targetSchema.fact_league_standings")

    // === HEAD-TO-HEAD AGGREGATES ===
    val pairDf = factMatchEnriched.select("match_id", "match_date", "home_team_id", "away_team_id", "home_team_goal", "away_team_goal")
      .withColumn("team_a", least(col("home_team_id"), col("away_team_id")))
      .withColumn("team_b", greatest(col("home_team_id"), col("away_team_id")))
      .withColumn("a_goals", when(col("team_a") === col("home_team_id"), col("home_team_goal")).otherwise(col("away_team_goal")))
      .withColumn("b_goals", when(col("team_b") === col("away_team_id"), col("away_team_goal")).otherwise(col("home_team_goal")))

    val headToHead = pairDf.groupBy("team_a", "team_b")
      .agg(
        count("match_id").alias("meetings"),
        sum(when(col("a_goals") > col("b_goals"), 1).otherwise(0)).alias("a_wins"),
        sum(when(col("a_goals") === col("b_goals"), 1).otherwise(0)).alias("draws"),
        sum(when(col("a_goals") < col("b_goals"), 1).otherwise(0)).alias("b_wins"),
        sum("a_goals").alias("a_goals_total"),
        sum("b_goals").alias("b_goals_total"),
        round(sum(when(col("a_goals") > col("b_goals"), 1).otherwise(0)) / count("match_id"), 3).alias("a_win_rate"),
        round(sum(when(col("a_goals") < col("b_goals"), 1).otherwise(0)) / count("match_id"), 3).alias("b_win_rate")
      )
      .persist()

    writeTable(headToHead, s"$targetSchema.fact_head_to_head")

    // === RIVALRIES (filter headToHead by meetings threshold) ===
    val rivalries = headToHead.filter(col("meetings") >= minRivalryMeetings)
    writeTable(rivalries, s"$targetSchema.fact_rivalries")

    // === HIGH SCORING MATCHES ===
    val highScoringMatches = factMatchEnriched
      .withColumn("total_goals", col("home_team_goal") + col("away_team_goal"))
      .select("match_id", "season", "league_id", "match_date", "home_team_id", "away_team_id", "home_team_goal", "away_team_goal", "total_goals")
      .orderBy(col("total_goals").desc)
      .persist()

    writeTable(highScoringMatches, s"$targetSchema.fact_high_scoring_matches")

    // === GOAL DISTRIBUTION (season + league level aggregates suitable for viz) ===
    val goalDistribution = factMatchEnriched
      .withColumn("total_goals", col("home_team_goal") + col("away_team_goal"))
      .groupBy("season", "league_id")
      .agg(
        round(avg("total_goals"), 3).alias("avg_total_goals"),
        expr("percentile_approx(total_goals, 0.5)").alias("median_total_goals"),
        min("total_goals").alias("min_total_goals"),
        max("total_goals").alias("max_total_goals"),
        count("*").alias("matches_count")
      )

    writeTable(goalDistribution, s"$targetSchema.fact_goal_distribution")

    // === TEAM-LEVEL: MOST GOALS (overall & per season) ===
    val teamGoalsOverall = teamMatchPerspective.groupBy("team_id")
      .agg(sum("goals_for").alias("total_goals"))
      .join(dimTeam.select("team_id", "team_name"), Seq("team_id"), "left")
      .select("team_id", "team_name", "total_goals")
      .orderBy(desc("total_goals"))

    writeTable(teamGoalsOverall, s"$targetSchema.fact_team_goals_overall")

    val teamGoalsBySeason = teamMatchPerspective.groupBy("season", "team_id")
      .agg(sum("goals_for").alias("season_goals"))
      .join(dimTeam.select("team_id", "team_name"), Seq("team_id"), "left")
      .select("season", "team_id", "team_name", "season_goals")
      .orderBy("season", desc("season_goals"))

    writeTable(teamGoalsBySeason, s"$targetSchema.fact_team_goals_by_season")

    // === TEAM-LEVEL: MOST WINS (overall & per season) ===
    val teamWinsOverall = teamMatchPerspective.filter(col("points") === 3)
      .groupBy("team_id")
      .agg(count("*").alias("wins"))
      .join(dimTeam.select("team_id", "team_name"), Seq("team_id"), "left")
      .select("team_id", "team_name", "wins")
      .orderBy(desc("wins"))

    writeTable(teamWinsOverall, s"$targetSchema.fact_team_wins_overall")

    val teamWinsBySeason = teamMatchPerspective.filter(col("points") === 3)
      .groupBy("season", "team_id")
      .agg(count("*").alias("season_wins"))
      .join(dimTeam.select("team_id", "team_name"), Seq("team_id"), "left")
      .select("season", "team_id", "team_name", "season_wins")
      .orderBy("season", desc("season_wins"))

    writeTable(teamWinsBySeason, s"$targetSchema.fact_team_wins_by_season")

    // === TEAM-LEVEL: LONGEST WIN STREAK ===
    val winFlag = teamMatchPerspective.withColumn("is_win", when(col("points") === 3, 1).otherwise(0))
    val winGrpWindow = Window.partitionBy("team_id").orderBy(col("match_date").cast("timestamp"))
    val winStreakId = sum(when(col("is_win") === 0, 1).otherwise(0)).over(winGrpWindow)
    val winStreaks = winFlag.withColumn("streak_id", winStreakId)
      .groupBy("team_id", "streak_id")
      .agg(sum("is_win").alias("streak_length"), min("match_date").alias("start_date"), max("match_date").alias("end_date"))
      .groupBy("team_id")
      .agg(max("streak_length").alias("max_win_streak"))
      .join(dimTeam.select("team_id", "team_name"), Seq("team_id"), "left")
      .select("team_id", "team_name", "max_win_streak")
      .orderBy(desc("max_win_streak"))

    writeTable(winStreaks, s"$targetSchema.fact_team_max_win_streak")

    // === TEAM-LEVEL: LONGEST SCORING STREAK (consecutive matches scoring at least 1 goal) ===
    val scoreFlag = teamMatchPerspective.withColumn("scored", when(col("goals_for") > 0, 1).otherwise(0))
    val scoreGrpWindow = Window.partitionBy("team_id").orderBy(col("match_date").cast("timestamp"))
    val scoreStreakId = sum(when(col("scored") === 0, 1).otherwise(0)).over(scoreGrpWindow)
    val scoringStreaks = scoreFlag.withColumn("streak_id", scoreStreakId)
      .groupBy("team_id", "streak_id")
      .agg(sum("scored").alias("scoring_streak_length"))
      .groupBy("team_id")
      .agg(max("scoring_streak_length").alias("max_scoring_streak"))
      .join(dimTeam.select("team_id", "team_name"), Seq("team_id"), "left")
      .select("team_id", "team_name", "max_scoring_streak")
      .orderBy(desc("max_scoring_streak"))

    writeTable(scoringStreaks, s"$targetSchema.fact_team_max_scoring_streak")

    // === PLAYER-LEVEL: attempt (only if events table exists) ===
    // We will try to load a table called "Match_Event" or "Event" or "MatchEvents" if present.
    val possibleEventTables = Seq("Match_Event", "Event", "MatchEvents", "MatchEvents2", "MatchEvent")
    var eventsDF: DataFrame = spark.emptyDataFrame
    for (t <- possibleEventTables if eventsDF.rdd.isEmpty()) {
      try {
        val tmp = readTable(spark, t)
        if (tmp.columns.nonEmpty) {
          eventsDF = tmp
        }
      } catch {
        case _: Throwable => // ignore and try next
      }
    }

    if (eventsDF.rdd.isEmpty()) {
      println("â„¹ï¸ No match-events table found (player-level goals/assists/xG skipped). If you have event table name, add it as one of possibleEventTables.")
    } else {
      println(s"âœ… Found events table with columns: ${eventsDF.columns.mkString(", ")}")
      // Try to compute player goals/assists if columns exist
      val lowerCols = eventsDF.columns.map(_.toLowerCase()).toSet

      // Heuristics for column names
      val playerCol = eventsDF.columns.find(c => Seq("player_id", "player_api_id", "playerid", "player").contains(c.toLowerCase())).getOrElse("")
      val eventTypeCol = eventsDF.columns.find(c => Seq("event_type", "type", "event").contains(c.toLowerCase())).getOrElse("")
      val subTypeCol = eventsDF.columns.find(c => Seq("event_subtype", "subtype").contains(c.toLowerCase())).getOrElse("")
      val shotDistCol = eventsDF.columns.find(c => Seq("shot_distance", "distance").contains(c.toLowerCase())).getOrElse("")
      val assistCol = eventsDF.columns.find(c => Seq("assist_player_id", "assist", "assist_player").contains(c.toLowerCase())).getOrElse("")

      val ev = eventsDF

      // PLAYER GOALS (requires event_type indicating 'goal' or subtype)
      val goalEvents = if (eventTypeCol.nonEmpty) {
        ev.filter(lower(col(eventTypeCol)).contains("goal") || lower(col(eventTypeCol)) === lit("goal"))
      } else if (subTypeCol.nonEmpty) {
        ev.filter(lower(col(subTypeCol)).conta
